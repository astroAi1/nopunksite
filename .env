// Static server + OpenSea proxy (collection-first)
require('dotenv').config();

const path = require('path');
const express = require('express');
const compression = require('compression');

const app = express();
const PORT = process.env.PORT || 3000;

const OS_CHAIN = (process.env.CHAIN || 'base').toLowerCase();
const OS_CONTRACT = String(process.env.CONTRACT || '0x4ed83635e2309a7c067d0f98efca47b920bf79b1').toLowerCase();
const OS_SLUG = process.env.COLLECTION_SLUG || 'nopunkism';
const OS_API_BASE = 'https://api.opensea.io/api/v2';

// --- static files ---
app.use(compression());
app.use(express.static(path.join(__dirname)));

function hasKey() {
  return typeof process.env.OPENSEA_API_KEY === 'string' && process.env.OPENSEA_API_KEY.trim() !== '';
}

async function osFetch(url) {
  const r = await fetch(url, {
    headers: {
      'accept': 'application/json',
      'X-API-KEY': process.env.OPENSEA_API_KEY || ''
    }
  });
  return r;
}

// Health check
app.get('/api/health', (req, res) => {
  res.json({ ok: true, chain: OS_CHAIN, contract: OS_CONTRACT, slug: OS_SLUG, hasKey: hasKey() });
});

// OpenSea: list NFTs by collection (preferred)
app.get('/api/opensea/collection_nfts', async (req, res) => {
  try {
    const limit = Math.max(1, Math.min(50, parseInt(req.query.limit, 10) || 50));
    const cursor = req.query.cursor || '';
    const api = new URL(`${OS_API_BASE}/collection/${encodeURIComponent(OS_SLUG)}/nfts`);
    api.searchParams.set('limit', String(limit));
    if (cursor) api.searchParams.set('next', cursor);

    const rr = await osFetch(api);
    const text = await rr.text();
    let data; try { data = JSON.parse(text); } catch { data = { raw: text }; }
    if (!rr.ok) console.error('OpenSea collection error', rr.status, data);
    res.status(rr.status).json(data);
  } catch (err) {
    console.error('OpenSea proxy (collection) failed:', err);
    res.status(500).json({ error: 'OpenSea proxy (collection) failed', detail: String(err?.message || err) });
  }
});

// OpenSea: list NFTs by contract (fallback)
app.get('/api/opensea/nfts', async (req, res) => {
  try {
    const limit = Math.max(1, Math.min(50, parseInt(req.query.limit, 10) || 50));
    const cursor = req.query.cursor || '';
    const api = new URL(`${OS_API_BASE}/chain/${OS_CHAIN}/contract/${OS_CONTRACT}/nfts`);
    api.searchParams.set('limit', String(limit));
    if (cursor) api.searchParams.set('next', cursor);

    const rr = await osFetch(api);
    const text = await rr.text();
    let data; try { data = JSON.parse(text); } catch { data = { raw: text }; }
    if (!rr.ok) console.error('OpenSea contract error', rr.status, data);
    res.status(rr.status).json(data);
  } catch (err) {
    console.error('OpenSea proxy (contract) failed:', err);
    res.status(500).json({ error: 'OpenSea proxy (contract) failed', detail: String(err?.message || err) });
  }
});

// OpenSea: single NFT by identifier
app.get('/api/opensea/nft/:id', async (req, res) => {
  try {
    const id = String(req.params.id);
    const api = `${OS_API_BASE}/chain/${OS_CHAIN}/contract/${OS_CONTRACT}/nfts/${id}`;
    const rr = await osFetch(api);
    const text = await rr.text();
    let data; try { data = JSON.parse(text); } catch { data = { raw: text }; }
    if (!rr.ok) console.error('OpenSea single error', rr.status, data);
    res.status(rr.status).json(data);
  } catch (err) {
    console.error('OpenSea single NFT proxy failed:', err);
    res.status(500).json({ error: 'OpenSea single NFT proxy failed', detail: String(err?.message || err) });
  }
});

app.listen(PORT, () => {
  console.log(`NoPunks dev server http://localhost:${PORT}`);
  console.log(`chain=${OS_CHAIN} contract=${OS_CONTRACT} slug=${OS_SLUG} key=${hasKey() ? '✅' : '❌'}`);
});
