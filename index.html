<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="Cache-Control" content="no-store, max-age=0, must-revalidate" />
  <title>No-Punks</title>

  <style>
    /* Local font: RasterForge for all text */
    @font-face{
      font-family:'RasterForge';
      src:url('/RasterForgeRegular-JpBgm.ttf') format('truetype');
      font-weight:400; font-style:normal; font-display:swap;
    }

    :root{
      --ink:#e7f5ff; --muted:#9fd8ff; --accent:#73d0ff;
      --card:#0c0c0c; --border:#2a2a2a;
      --shadow:0 0 0 1px var(--border), 0 12px 30px rgba(0,0,0,.6);
      --maxw: 1240px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:#000 url('/Gbh4rY5aUAAtNS7.jpeg') center/cover fixed no-repeat;
      color:var(--ink);
      font-family:'RasterForge', ui-monospace, Menlo, monospace;
      letter-spacing:.4px;
    }

    .overlay{ min-height:100%; background:linear-gradient(180deg, rgba(0,0,0,.85), rgba(0,0,0,.92)); }
    .container{ max-width:var(--maxw); margin:0 auto; padding:28px; }

    /* ===== Centered masthead ===== */
    .masthead{ display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center; margin-bottom:16px; }
    .logo{
      margin:0;
      font-size:clamp(48px, 7vw, 92px);
      line-height:1.05; letter-spacing:.02em;
      color:#ffffff; /* header text in white */
      text-shadow:0 0 3px #040404, 0 0 10px #040404; /* subtle dark glow */
    }

    /* ===== Social icons (centered under header) ===== */
    .social{ display:flex; gap:12px; justify-content:center; margin-top:8px; }
    .social a{ display:inline-flex; align-items:center; justify-content:center; width:36px; height:36px; border:1px solid var(--border); background:rgba(12,12,12,.78); border-radius:8px; box-shadow:var(--shadow); text-decoration:none; }
    .social a:hover{ border-color:var(--accent); box-shadow:0 0 12px rgba(115,208,255,.25) inset; }
    .social img{ width:22px; height:22px; border-radius:4px; display:block; }

    /* ===== One horizontal tab row under the title ===== */
    .tabs{ display:flex; justify-content:center; gap:10px; margin:18px 0 22px; flex-wrap:wrap; }
    .tab{
      padding:10px 14px; border:1px solid var(--border);
      background:rgba(12,12,12,.78); border-radius:8px; cursor:pointer; color:var(--ink); font-size:15px;
    }
    .tab:hover{ border-color:var(--accent); color:var(--accent); }
    .tab.active{ border-color:var(--accent); color:var(--accent); box-shadow:0 0 12px rgba(115,208,255,.25) inset; }
    .section{ display:none; }
    .section.active{ display:block; }

    /* ===== Collection ===== */
    .controls{ display:flex; gap:12px; align-items:center; justify-content:center; margin:10px 0 18px; flex-wrap:wrap; }
    .btn{ background:#000; color:var(--ink); border:1px solid var(--border); border-radius:8px; padding:10px 14px; cursor:pointer; }
    .btn:hover{ border-color:var(--accent); color:var(--accent); }
    .range{ opacity:.85; }

    .grid{ display:grid; grid-template-columns:repeat(auto-fill, minmax(136px, 1fr)); gap:12px; max-width:var(--maxw); margin:0 auto; }
    .tile{
      background:var(--card); border:1px solid var(--border); border-radius:10px; overflow:hidden; box-shadow:var(--shadow);
      position:relative; aspect-ratio:1/1; display:flex; align-items:center; justify-content:center; cursor:pointer;
    }
    .tile img{ width:100%; height:100%; object-fit:contain; image-rendering:pixelated; background:#000; }
    .tile .num{ position:absolute; left:8px; top:8px; font-size:12px; color:var(--muted); }

    .tooltip{ position:fixed; display:none; z-index:9999; background:rgba(0,0,0,.92); border:1px solid var(--border); padding:12px; border-radius:8px; width:280px; pointer-events:none; white-space:pre-wrap; box-shadow:var(--shadow) }
    .tooltip h4{ margin:0 0 8px; color:var(--accent) }

    /* ===== Search ===== */
    .search-wrap{ display:flex; flex-direction:column; align-items:center; gap:12px; }
    .search-controls{ display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; margin:10px 0; }
    .search-input{ padding:10px 12px; border:1px solid var(--border); background:#000; color:var(--ink); border-radius:8px; font-size:15px; min-width:220px; }
    #searchCanvas{ width:1024px; height:1024px; border:1px solid var(--border); background:#000; image-rendering:pixelated; }
    #searchMeta{ color:var(--muted); text-align:center; }
    @media (max-width:1100px){ #searchCanvas{ width:90vw; height:90vw; } }

    /* ===== Team ===== */
    /* ===== No-Meta (other collections) ===== */
    .nometa-grid{ display:grid; grid-template-columns:repeat(auto-fit, minmax(240px,1fr)); gap:16px; max-width:var(--maxw); margin:0 auto; }
    .nometa-card{ background:rgba(12,12,12,.78); border:1px solid var(--border); border-radius:12px; padding:12px; text-align:center; box-shadow:var(--shadow); }
    .nometa-card a{ display:block; text-decoration:none; color:var(--ink); }
    .nometa-card img{ width:100%; aspect-ratio:1/1; object-fit:cover; border-radius:10px; border:1px solid var(--border); image-rendering:pixelated; background:#000; }
    .nometa-card .name{ margin-top:10px; color:var(--accent); }
    .team-grid{ display:grid; grid-template-columns:repeat(auto-fit, minmax(200px,1fr)); gap:16px; max-width:var(--maxw); margin:0 auto; }
    .member{ background:rgba(12,12,12,.78); border:1px solid var(--border); border-radius:12px; padding:12px; text-align:center; box-shadow:var(--shadow); }
    .member img{ width:100%; aspect-ratio:1/1; object-fit:cover; border-radius:10px; border:1px solid var(--border); image-rendering:pixelated; background:#000; }
    .member .name{ margin-top:10px; color:var(--accent); }

    /* ===== About ===== */
    .about{ background:rgba(12,12,12,.78); border:1px solid var(--border); border-radius:12px; padding:18px; line-height:1.9; box-shadow:var(--shadow); max-width:var(--maxw); margin:0 auto; }
    .about strong{ color:var(--accent); }

    footer{ margin-top:28px; color:var(--muted); text-align:center; }
  </style>
</head>
<body>
  <div class="overlay">
    <div class="container">
      <header class="masthead">
        <h1 class="logo">No-Punks</h1>
        <nav class="social" aria-label="Social links">
          <!-- X / Twitter (uses OSHY image) -->
          <a href="https://x.com/NoPunkism" target="_blank" rel="noopener noreferrer" aria-label="X (Twitter)">
            <img src="/OSHY3ewP_400x400.jpg" alt="X (Twitter)" loading="lazy" decoding="async" />
          </a>
          <!-- OpenSea (uses UAEvW2or image) -->
          <a href="https://opensea.io/collection/nopunkism" target="_blank" rel="noopener noreferrer" aria-label="OpenSea collection">
            <img src="/UAEvW2or_400x400.png" alt="OpenSea" loading="lazy" decoding="async" />
          </a>
        </nav>
      </header>

      <!-- ONE tabs row -->
      <div class="tabs" id="tabs">
        <button class="tab active" data-target="collection">Collection</button>
        <button class="tab" data-target="search">Search</button>
        <button class="tab" data-target="traits">Traits</button>
        <button class="tab" data-target="no-meta">No-Meta</button>
        <button class="tab" data-target="team">Team</button>
        <button class="tab" data-target="about">About</button>
      </div>

      <!-- Collection -->
      <section id="collection" class="section active">
        <div class="controls">
          <button id="prev" class="btn">← Prev</button>
          <span id="label" class="range"></span>
          <label for="pageSize" class="range">Per page:</label>
          <select id="pageSize" class="btn" style="padding:8px 10px">
            <option value="25">25</option>
            <option value="50" selected>50</option>
            <option value="100">100</option>
          </select>
          <button id="next" class="btn">Next →</button>
        </div>
        <div class="grid" id="grid"></div>
      </section>

      <!-- Search -->
      <section id="search" class="section">
        <div class="search-wrap">
          <div class="search-controls">
            <input id="searchInput" class="search-input" placeholder="#0–9999 e.g. #46" inputmode="numeric" />
            <button id="searchBtn" class="btn">Search</button>
          </div>
          <canvas id="searchCanvas" width="1024" height="1024"></canvas>
          <div id="searchMeta" class="range"></div>
        </div>
      </section>

      <!-- Traits -->
      <section id="traits" class="section">
        <div class="search-wrap">
          <div class="search-controls">
            <label class="range" for="traitTypeSel">Type:</label>
            <select id="traitTypeSel" class="btn"></select>
            <label class="range" for="traitValueSel">Value:</label>
            <select id="traitValueSel" class="btn"></select>
            <span class="range">or quick text:</span>
            <input id="traitQuery" class="search-input" placeholder="e.g., 3D Glasses" />
            <button id="traitFindBtn" class="btn">Find Matches</button>
            <button id="traitStopBtn" class="btn">Stop</button>
          </div>
          <div id="traitProgress" class="range"></div>
          <div id="traitGrid" class="grid"></div>
        </div>
      </section>

      <!-- No-Meta -->
      <section id="no-meta" class="section">
        <div class="nometa-grid">
          <figure class="nometa-card">
            <a href="https://opensea.io/collection/no-pixelpepen" target="_blank" rel="noopener">
              <img src="/cb04413e8456e1d457159cfdf2cfdbe3.gif" alt="NoPixelpepen" loading="lazy" decoding="async" />
              <figcaption class="name">NoPixelpepen</figcaption>
            </a>
          </figure>

          <figure class="nometa-card">
            <a href="https://opensea.io/collection/no-tinydinopunks" target="_blank" rel="noopener">
              <img src="/cc2dd813629a7e256fafb253dd42edb8.png.avif" alt="No-TinyDinoPunks" loading="lazy" decoding="async" />
              <figcaption class="name">No-TinyDinoPunks</figcaption>
            </a>
          </figure>

          <figure class="nometa-card">
            <a href="https://opensea.io/collection/no-pnuks" target="_blank" rel="noopener">
              <img src="/839f1c66dedac508eb0620a0ce3f4a93.png.avif" alt="No-Pnuks" loading="lazy" decoding="async" />
              <figcaption class="name">No-Pnuks</figcaption>
            </a>
          </figure>
        </div>
      </section>

      <!-- Team -->
      <section id="team" class="section">
        <div class="team-grid">
          <figure class="member">
            <a href="https://x.com/Astro___AI" target="_blank" rel="noopener noreferrer" aria-label="Astro on X">
              <img src="/team/Astro.png" alt="Astro" />
            </a>
            <figcaption class="name">Astro</figcaption>
          </figure>
          <figure class="member">
            <a href="https://x.com/BB88888888888BB" target="_blank" rel="noopener noreferrer" aria-label="B888B on X">
              <img src="/team/B888B.png" alt="B888B" />
            </a>
            <figcaption class="name">B888B</figcaption>
          </figure>
          <figure class="member">
            <a href="https://x.com/holu_art" target="_blank" rel="noopener noreferrer" aria-label="Holu on X">
              <img src="/team/Holu.png" alt="Holu" />
            </a>
            <figcaption class="name">Holu</figcaption>
          </figure>
        </div>
      </section>

      <!-- About -->
      <section id="about" class="section">
        <div class="about">
          <p><strong>No-punks</strong> is a simplified iteration of the CryptoPunks collection by color palette reduction. The reduced color palette and simplified details contribute to a more abstract and minimalist aesthetic, emphasizing a uniform look while retaining the essence of the original image. Collection is prepared as <strong>1:1</strong> to stay true to the original CryptoPunks. <em>This collection may or may not be visible!</em></p>
        </div>
      </section>

      <footer>© No-Punks</footer>
    </div>
  </div>

  <div class="tooltip" id="tooltip"></div>

  <script type="module">
    import { TRAIT_VALUES_BY_TYPE, TRAIT_TYPES } from '/trait_values_by_type.js';
    window.TRAIT_VALUES_BY_TYPE = TRAIT_VALUES_BY_TYPE;
    window.TRAIT_TYPES = TRAIT_TYPES;
  </script>

  <!-- INLINE JS so there is no external path issue -->
  <script>
    console.log('No-Punks inline JS booted');

    // ---------- Tabs (event delegation) ----------
    function activate(targetId){
      document.querySelectorAll('.tab')
        .forEach(b => b.classList.toggle('active', b.dataset.target === targetId));
      document.querySelectorAll('.section')
        .forEach(s => s.classList.toggle('active', s.id === targetId));
    }

    document.addEventListener('click', (e) => {
      const btn = e.target.closest('.tab');
      if (!btn) return;
      const targetId = btn.dataset.target; if (!targetId) return;
      activate(targetId);
      if (targetId === 'collection' && !document.getElementById('grid').childElementCount) {
        loadRange(0);
      }
    });

    // ---------- Collection from /collection ----------
    const TOTAL = 10000;  // 0..9999
    let pageSize = 25;   // safer initial page size
    let start = 0;

    const grid  = document.getElementById('grid');
    const label = document.getElementById('label');
    const tip   = document.getElementById('tooltip');
    const metaCache = new Map();

    const pageSizeSel = document.getElementById('pageSize');
    if (pageSizeSel) {
      pageSizeSel.addEventListener('change', () => {
        pageSize = parseInt(pageSizeSel.value, 10) || 50;
        loadRange(start);
      });
    }

    function clampStart(x){
      if (x < 0) return 0;
      const maxStart = Math.max(0, TOTAL - pageSize);
      return Math.min(x, maxStart);
    }

    async function getMeta(id){
      if (metaCache.has(id)) return metaCache.get(id);
      const candidates = [
        `/${id}.json`,
        `/collection/${id}.json`,
        `/collection/transparent/${id}.json`,
        `/collection/figmanopunks/${id}.json`,
        `/collection/larvallads/${id}.json`
      ];
      for (const url of candidates){
        try{
          const r = await fetch(url, { cache: 'force-cache' });
          if (r.ok){
            const j = await r.json();
            metaCache.set(id, j);
            return j;
          }
        }catch{ /* try next */ }
      }
      const fallback = { name:`No-Punk #${id}`, attributes:[] };
      metaCache.set(id, fallback);
      return fallback;
    }

    function traitText(meta){
      const attrs = meta.attributes || meta.traits || [];
      if (!Array.isArray(attrs) || !attrs.length) return '';
      return attrs.map(a => `${a.trait_type ?? a.type ?? 'Trait'}: ${a.value}`).join('\n');
    }

    function showTip(x, y, html){
      tip.innerHTML = html;
      tip.style.left = (x + 14) + 'px';
      tip.style.top  = (y + 14) + 'px';
      tip.style.display = 'block';
    }
    function hideTip(){ tip.style.display = 'none'; }

    const io = ('IntersectionObserver' in window) ? new IntersectionObserver(entries => {
      for (const entry of entries) {
        if (entry.isIntersecting || entry.intersectionRatio > 0) {
          const img = entry.target;
          const ds = img.getAttribute('data-src');
          if (ds && !img.getAttribute('src')) {
            img.setAttribute('src', ds);
          }
          io.unobserve(img);
        }
      }
    }, { rootMargin: '400px 0px', threshold: 0.01 }) : null;

    function tile(id){
      const a = document.createElement('a');
      a.className = 'tile';
      a.href = `/${id}.png`;
      a.target = '_blank'; a.rel = 'noopener';

      const num = document.createElement('span');
      num.className = 'num';
      num.textContent = `#${id}`;
      a.appendChild(num);

      const img = document.createElement('img');
      img.alt = `No-Punk #${id}`;
      img.loading = 'lazy';
      img.decoding = 'async';

      // Candidate image locations (root first, then known subfolders)
      const candidates = [
        `/${id}.png`,
        `/collection/${id}.png`,
        `/collection/transparent/${id}.png`,
        `/collection/figmanopunks/${id}.png`,
        `/collection/larvallads/${id}.png`
      ];
      let ci = 0; // current candidate index

      // Set data-src to the first candidate for IO to pick up
      img.setAttribute('data-src', candidates[ci]);
      a.appendChild(img);

      // Try next candidate on error
      img.addEventListener('error', () => {
        ci += 1;
        if (ci < candidates.length){
          img.setAttribute('data-src', candidates[ci]);
          // If already intersecting, re-trigger load immediately
          if (!io){
            img.src = img.getAttribute('data-src');
          } else {
            io.observe(img);
          }
        } else {
          // Give up on image but keep the tile (still hoverable for traits)
          img.remove();
        }
      });

      if (io) { io.observe(img); } else { img.setAttribute('src', img.getAttribute('data-src')); }

      const move = async (e)=>{
        const p = e.touches ? e.touches[0] : e;
        const meta = await getMeta(id);
        const name = meta.name || `No-Punk #${id}`;
        const traits = traitText(meta);
        const html = `<h4>${name}</h4>${traits ? traits.replace(/\n/g,'<br>') : 'No traits'}`;
        showTip(p.clientX, p.clientY, html);
      };
      a.addEventListener('mouseenter', move);
      a.addEventListener('mousemove', move);
      a.addEventListener('mouseleave', hideTip);
      a.addEventListener('touchstart', move, {passive:true});
      a.addEventListener('touchmove', move, {passive:true});
      a.addEventListener('touchend', hideTip);

      return a;
    }

    function parseId(val){
      if (!val) return NaN;
      let t = String(val).trim();
      if (t.startsWith('#')) t = t.slice(1);
      const n = parseInt(t, 10);
      return (isNaN(n) || n < 0 || n >= TOTAL) ? NaN : n;
    }

    function loadImageWithFallback(id){
      const candidates = [
        `/${id}.png`,
        `/collection/${id}.png`,
        `/collection/transparent/${id}.png`,
        `/collection/figmanopunks/${id}.png`,
        `/collection/larvallads/${id}.png`
      ];
      let i = 0;
      return new Promise((resolve, reject)=>{
        const tryNext = ()=>{
          if (i >= candidates.length) return reject(new Error('image not found'));
          const im = new Image();
          im.onload = ()=> resolve(im);
          im.onerror = ()=> { i++; tryNext(); };
          im.src = candidates[i];
        };
        tryNext();
      });
    }

    // ---------- Trait search helpers ----------
    function norm(s){ return String(s || '').toLowerCase().trim(); }

    function initTraitUI(){
      const typeSel  = document.getElementById('traitTypeSel');
      const valueSel = document.getElementById('traitValueSel');
      if (!typeSel || !valueSel) return;

      // Populate types
      const types = (window.TRAIT_TYPES && Array.isArray(window.TRAIT_TYPES)) ? window.TRAIT_TYPES : [];
      typeSel.innerHTML = types.map(t => `<option value="${t}">${t}</option>`).join('');

      function refreshValues(){
        const t = typeSel.value;
        const byType = window.TRAIT_VALUES_BY_TYPE || {};
        const values = Array.isArray(byType[t]) ? byType[t] : [];
        valueSel.innerHTML = values.map(v => `<option value="${v}">${v}</option>`).join('');
      }

      if (types.length){ typeSel.value = types[0]; }
      refreshValues();

      typeSel.addEventListener('change', refreshValues);
    }

    function metaHasTrait(meta, qType, qValue, qText){
      const attrs = meta && (meta.attributes || meta.traits) || [];
      const tText = norm(qText);
      const tType = norm(qType);
      const tVal  = norm(qValue);
      for (const a of attrs){
        const at = norm(a.trait_type || a.type);
        const av = norm(a.value);
        if (tText){
          if (av.includes(tText) || at.includes(tText)) return true;
        } else {
          if ((tType ? at === tType : true) && (tVal ? av === tVal : true)) return true;
        }
      }
      return false;
    }

    let traitScanCancel = false;

    async function searchTraits(){
      const typeSel  = document.getElementById('traitTypeSel');
      const valueSel = document.getElementById('traitValueSel');
      const qInput   = document.getElementById('traitQuery');
      const gridEl   = document.getElementById('traitGrid');
      const progEl   = document.getElementById('traitProgress');
      if (!gridEl || !progEl) return;

      const qType = typeSel ? typeSel.value : '';
      const qVal  = valueSel ? valueSel.value : '';
      const qText = qInput ? qInput.value : '';

      gridEl.innerHTML = '';
      progEl.textContent = 'Scanning 0 – 9,999…';
      traitScanCancel = false;

      const CHUNK = 100; // fetch 100 metas at a time
      let found = 0;

      for (let base = 0; base < TOTAL; base += CHUNK){
        if (traitScanCancel) { progEl.textContent = `Stopped. Found ${found}`; return; }
        const end = Math.min(base + CHUNK, TOTAL);
        const ids = Array.from({length: end - base}, (_,i)=> base + i);
        const metas = await Promise.all(ids.map(id => getMeta(id)));
        for (let i=0;i<ids.length;i++){
          const id = ids[i];
          const meta = metas[i];
          if (metaHasTrait(meta, qType, qVal, qText)){
            gridEl.appendChild(tile(id));
            found++;
          }
        }
        progEl.textContent = `Scanning ${base} – ${end-1} / 9999 • Found ${found}`;
        await new Promise(r => setTimeout(r, 0)); // yield to UI
      }
      progEl.textContent = `Done. Found ${found}`;
    }

    async function renderSingle(id){
      const canvas = document.getElementById('searchCanvas');
      const ctx = canvas.getContext('2d');
      ctx.imageSmoothingEnabled = false;
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      try{
        const img = await loadImageWithFallback(id);
        const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
        const w = Math.round(img.width * scale);
        const h = Math.round(img.height * scale);
        const x = Math.floor((canvas.width - w)/2);
        const y = Math.floor((canvas.height - h)/2);
        ctx.drawImage(img, x, y, w, h);
        const meta = await getMeta(id);
        const traits = traitText(meta).replace(/\n/g,'<br>');
        document.getElementById('searchMeta').innerHTML = `<h4>No-Punk #${id}</h4>${traits || 'No traits'}`;
      }catch(err){
        document.getElementById('searchMeta').innerHTML = `No image found for #${id}`;
      }
    }

    async function loadRange(s){
      start = clampStart(s);
      if (label) label.textContent = `${start} – ${start + pageSize - 1}`;
      hideTip();
      grid.innerHTML = '';
      const ids = Array.from({ length: pageSize }, (_, k) => start + k);
      for (const id of ids){
        grid.appendChild(tile(id));
      }
    }

    document.getElementById('prev').addEventListener('click', ()=> loadRange(start - pageSize));
    document.getElementById('next').addEventListener('click', ()=> loadRange(start + pageSize));

    // Boot: default to Collection
    window.addEventListener('DOMContentLoaded', ()=>{
      activate('collection');
      loadRange(0);

      const sInput = document.getElementById('searchInput');
      const sBtn   = document.getElementById('searchBtn');
      if (sBtn && sInput){
        sBtn.addEventListener('click', ()=>{
          const id = parseId(sInput.value);
          if (isNaN(id)) { alert('Enter #0–9999'); return; }
          activate('search');
          renderSingle(id);
        });
        sInput.addEventListener('keydown', (e)=>{
          if (e.key === 'Enter') sBtn.click();
        });
      }

      // Traits UI wiring
      initTraitUI();
      const traitBtn = document.getElementById('traitFindBtn');
      const stopBtn  = document.getElementById('traitStopBtn');
      if (traitBtn){
        traitBtn.addEventListener('click', ()=>{
          activate('traits');
          searchTraits();
        });
      }
      if (stopBtn){
        stopBtn.addEventListener('click', ()=>{ traitScanCancel = true; });
      }
    });
  </script>
</body>
</html>